spatialData <- as.data.frame(p1) |>
dplyr::select(
species = taxon,
latitude,
longitude,
type
)
# testing
## Generate buffer objects
gBuffer <- generateGBuffers(
taxon = i,
occurrenceData = occurrenceData,
bufferDistM = buffSize
)
## geographic representativeness score  exsitu
grs_exsitu <- GRSex(taxon = i,
sdm = sdm,
gBuffer = gBuffer)
## map is not clipping the buffer objects to the distribution
## Ecological representativeness score exsitu
ers_exsitu <- ERSex(
taxon = i,
sdm = sdm,
occurrenceData = occurrenceData,
gBuffer = gBuffer,
ecoregions = ecoregions,
idColumn = "ECO_CODE"
)
# Running final conservation score ecoregionsexsitu
fcs_exsitu <- FCSex(
taxon = i,
srsex = srs_exsitu,
grsex = grs_exsitu,
ersex = ers_exsitu
)
# generate insitu conservation summaries
## sample representativeness score insitu
srs_insitu <- SRSin(
taxon = i,
sdm = sdm,
occurrenceData = spatialData,
protectedAreas = protectedAreas
)
## Geographic representativeness score insitu
grs_insitu <- GRSin(taxon = i, sdm = sdm, protectedAreas = protectedAreas)
## ecological representativeness score insitu
ers_insitu <- ERSin(
taxon = i,
sdm = sdm,
occurrenceData = occurrenceData,
protectedAreas = protectedAreas,
ecoregions = ecoregions,
idColumn = "ECO_CODE"
)
## final representativeness score insitu
fcs_insitu <- FCSin(
taxon = i,
srsin = srs_insitu,
grsin = grs_insitu,
ersin = ers_insitu
)
## combine conservation score
fcs_combine <- FCSc_mean(taxon = i, fcsin = fcs_insitu, fcsex = fcs_exsitu)
write_csv(x = fcs_combine, file = export)
} else {
fcs_combine <- read_csv(export)
}
if (n == 1) {
output <- fcs_combine
} else {
output <- bind_rows(output, fcs_combine)
}
n = n + 1
}
write_csv(x = output, file = paste0("data/Vitis/varBuffer/summaryTable_",buffSize,".csv" ))
#
# Do a direct comparison of the ERSex functions between the source --------
buffSize <- 100000
# custom ERSex function to account for the native area features -----------
# gap analysis functions
ERSex <- function (taxon, sdm, occurrenceData, gBuffer, ecoregions, idColumn){
# grab the point features from the occurrenceData
d1 <- terra::vect(dplyr::filter(occurrenceData, occurrenceData$species == taxon),
geom = c("longitude", "latitude"), crs = "+proj=longlat +datum=WGS84")
d1$color <- ifelse(d1$type == "H", yes = "#1184d4", no = "#6300f0")
# filter ecoregion to locations with point observations
eco1 <- ecoregions[d1,]
# select the ecoregions that are in the
eco1$id_column <- as.data.frame(eco1)[[idColumn]]
# eco1 <- terra::aggregate(x = eco1, by = "id_column")
eco1 <- terra::crop(eco1, sdm)
# this is the first measure, how much SDM in all the ecoregions
eco1$sdmSum <- terra::zonal(x = sdm, z = eco1, fun = "sum", na.rm = TRUE)
# filter to feaetures with values
ecoSelect <- eco1[eco1$sdmSum > 0, ]
# 15 features with distribution inside the ecoregions
eco2 <- dplyr::select(terra::as.data.frame(ecoSelect), ecoID = id_column,
count = sdmSum)
if (is.character(gBuffer$data)) {
ers <- 0
gEco <- NA
gEcoCounts <- 0
totalEcosCount <- nrow(ecoSelect)
missingEcos <- eco2$ecoID
} else {
b1 <- terra::mask(terra::rasterize(x = gBuffer$data,
y = sdm), sdm)
# three features with buffered ecos
# returning 9
eco2$bufferEcos <- unlist(terra::zonal(x = b1, z = ecoSelect,
fun = "sum", na.rm = TRUE))
ecoGrouped <- dplyr::summarise(
dplyr::group_by(dplyr::mutate(eco2,
bufferEcos = dplyr::case_when(
is.na(bufferEcos) ~                                            0, is.nan(bufferEcos) ~ 0, TRUE ~ bufferEcos)),
ecoID), inDistribution = sum(count, na.rm = TRUE),
inGBuffer = sum(bufferEcos, na.rm = TRUE))
totalEcosCount <- nrow(ecoGrouped)
#
gEcoIds <- pull(ecoGrouped[ecoGrouped$inGBuffer > 0,
"ecoID"])
gEcoCounts <- length(gEcoIds)
missingEcos <- ecoSelect[!ecoSelect$id_column %in% gEcoIds,
]
ers <- min(c(100, (gEcoCounts/totalEcosCount) * 100))
}
out_df = dplyr::tibble(Taxon = taxon, `Ecoregions with records` = totalEcosCount,
`Ecoregions within G buffer` = gEcoCounts, `ERS exsitu` = ers)
map_title <- "<h3 style='text-align:center; background-color:rgba(255,255,255,0.7); padding:2px;'>Ecoregions outside of the G Buffer areas</h3>"
map <- leaflet::addControl(leaflet::addLegend(leaflet::addPolygons(leaflet::addTiles(leaflet()),
data = ecoSelect, color = "#444444", weight = 1, opacity = 1,
fillOpacity = 0.1, popup = ~ECO_NAME, fillColor = NA),
position = "topright", title = "ERS ex situ", colors = c("#47ae24",
"#746fae", "#f0a01f", "#44444440"), labels = c("Distribution",
"G buffer", "Eco gaps", "All Ecos"), opacity = 1),
html = map_title, position = "bottomleft")
if (ers > 0) {
map <- leaflet::addCircleMarkers(leaflet::addRasterImage(leaflet::addRasterImage(leaflet::addPolygons(map,
data = missingEcos, color = "#444444", weight = 1,
opacity = 1, popup = ~ECO_NAME, fillOpacity = 0.5,
fillColor = "#f0a01f"), x = sdm, colors = "#47ae24"),
x = b1, colors = "#746fae"), data = d1, color = ~color,
radius = 2, opacity = 1)
}
else {
map <- leaflet::addCircleMarkers(map, data = d1, color = ~color,
radius = 2, opacity = 1)
}
output <- list(results = out_df, ecoGaps = missingEcos, map = map)
return(output)
}
n <- 1
for (i in species) {
export <- paste0("data/Vitis/varBuffer/", i, "_", buffSize, ".csv")
if (!file.exists(export)) {
print(i)
rs <- r2[grepl(pattern = paste0(i, "/"), x = r2)]
if (length(rs) == 0) {
next
}
sdm <- rast(rs)
sdm[sdm == 0, ] <- NA
p1 <- sf::st_read(s2[grepl(pattern = paste0(i,"/"), x = s2) ])
occurrenceData <- p1 |>
as.data.frame() |>
dplyr::select(
species= taxon,  latitude, longitude, type
)
# p1 <- vect(s2[grepl(pattern = paste0(i, "/"), x = s2)])
# limit ecoregions to the areas with known occurrences
# eco1 <- ecoregions[p1, ]
# occurrenceData is used for srsex
srs_exsitu <- GapAnalysis::SRSex(
taxon = i,
occurrence_Data = occurrenceData1
)
# need to use the spatial data as this is watch was evaluated within the model
spatialData <- as.data.frame(p1) |>
dplyr::select(
species = taxon,
latitude,
longitude,
type
)
# testing
## Generate buffer objects
gBuffer <- generateGBuffers(
taxon = i,
occurrenceData = occurrenceData,
bufferDistM = buffSize
)
## geographic representativeness score  exsitu
grs_exsitu <- GRSex(taxon = i,
sdm = sdm,
gBuffer = gBuffer)
## map is not clipping the buffer objects to the distribution
## Ecological representativeness score exsitu
ers_exsitu <- ERSex(
taxon = i,
sdm = sdm,
occurrenceData = occurrenceData,
gBuffer = gBuffer,
ecoregions = ecoregions,
idColumn = "ECO_CODE"
)
# Running final conservation score ecoregionsexsitu
fcs_exsitu <- FCSex(
taxon = i,
srsex = srs_exsitu,
grsex = grs_exsitu,
ersex = ers_exsitu
)
# generate insitu conservation summaries
## sample representativeness score insitu
srs_insitu <- SRSin(
taxon = i,
sdm = sdm,
occurrenceData = spatialData,
protectedAreas = protectedAreas
)
## Geographic representativeness score insitu
grs_insitu <- GRSin(taxon = i, sdm = sdm, protectedAreas = protectedAreas)
## ecological representativeness score insitu
ers_insitu <- ERSin(
taxon = i,
sdm = sdm,
occurrenceData = occurrenceData,
protectedAreas = protectedAreas,
ecoregions = ecoregions,
idColumn = "ECO_CODE"
)
## final representativeness score insitu
fcs_insitu <- FCSin(
taxon = i,
srsin = srs_insitu,
grsin = grs_insitu,
ersin = ers_insitu
)
## combine conservation score
fcs_combine <- FCSc_mean(taxon = i, fcsin = fcs_insitu, fcsex = fcs_exsitu)
write_csv(x = fcs_combine, file = export)
} else {
fcs_combine <- read_csv(export)
}
if (n == 1) {
output <- fcs_combine
} else {
output <- bind_rows(output, fcs_combine)
}
n = n + 1
}
output
buffSize
buffSize <- 100000
# rerun
pacman::p_load(terra, dplyr, readr, leaflet)
devtools::install_git("https://github.com/CIAT-DAPA/GapAnalysis")
library(GapAnalysis)
# load in ecoregion and protect areas data
## ecoregions
ecoregions <- sf::st_read(
"data/geospatial_datasets/ecoregions/tnc_terr_ecoregions.gpkg"
) |>
terra::vect()
## protect lands
protectedAreas <- terra::rast(
"data/geospatial_datasets/protectedLands/wdpa_1km_all_.tif"
)
# gather data
runVersion <- "run08282025_1k"
files <- list.files(path = "data/Vitis", full.names = TRUE, recursive = TRUE)
r1 <- files[grepl(pattern = runVersion, x = files)]
# load in all rasters
r2 <- r1[grepl(pattern = "prj_threshold.tif", x = r1)]
# load in data for species
s2 <- r1[grepl(pattern = "spatialData.gpkg", x = r1)]
speciesData <- read_csv("temp/allVitisData082025.csv")
species <- sort(unique(speciesData$taxon))
# org for gap r
occurrenceData1 <- speciesData |>
dplyr::select(
species = taxon,
latitude,
longitude,
type
)
buffSize <- 100000
# test some options
# i <- "Vitis arizonica"
# i <- "Vitis californica"
# custom ERSex function to account for the native area features -----------
# gap analysis functions
ERSex <- function (taxon, sdm, occurrenceData, gBuffer, ecoregions, idColumn){
# grab the point features from the occurrenceData
d1 <- terra::vect(dplyr::filter(occurrenceData, occurrenceData$species == taxon),
geom = c("longitude", "latitude"), crs = "+proj=longlat +datum=WGS84")
d1$color <- ifelse(d1$type == "H", yes = "#1184d4", no = "#6300f0")
# filter ecoregion to locations with point observations
eco1 <- ecoregions[d1,]
# select the ecoregions that are in the
eco1$id_column <- as.data.frame(eco1)[[idColumn]]
# eco1 <- terra::aggregate(x = eco1, by = "id_column")
eco1 <- terra::crop(eco1, sdm)
# this is the first measure, how much SDM in all the ecoregions
eco1$sdmSum <- terra::zonal(x = sdm, z = eco1, fun = "sum", na.rm = TRUE)
# filter to feaetures with values
ecoSelect <- eco1[eco1$sdmSum > 0, ]
# 15 features with distribution inside the ecoregions
eco2 <- dplyr::select(terra::as.data.frame(ecoSelect), ecoID = id_column,
count = sdmSum)
if (is.character(gBuffer$data)) {
ers <- 0
gEco <- NA
gEcoCounts <- 0
totalEcosCount <- nrow(ecoSelect)
missingEcos <- eco2$ecoID
} else {
b1 <- terra::mask(terra::rasterize(x = gBuffer$data,
y = sdm), sdm)
# three features with buffered ecos
# returning 9
eco2$bufferEcos <- unlist(terra::zonal(x = b1, z = ecoSelect,
fun = "sum", na.rm = TRUE))
ecoGrouped <- dplyr::summarise(
dplyr::group_by(dplyr::mutate(eco2,
bufferEcos = dplyr::case_when(
is.na(bufferEcos) ~                                            0, is.nan(bufferEcos) ~ 0, TRUE ~ bufferEcos)),
ecoID), inDistribution = sum(count, na.rm = TRUE),
inGBuffer = sum(bufferEcos, na.rm = TRUE))
totalEcosCount <- nrow(ecoGrouped)
#
gEcoIds <- pull(ecoGrouped[ecoGrouped$inGBuffer > 0,
"ecoID"])
gEcoCounts <- length(gEcoIds)
missingEcos <- ecoSelect[!ecoSelect$id_column %in% gEcoIds,
]
ers <- min(c(100, (gEcoCounts/totalEcosCount) * 100))
}
out_df = dplyr::tibble(Taxon = taxon, `Ecoregions with records` = totalEcosCount,
`Ecoregions within G buffer` = gEcoCounts, `ERS exsitu` = ers)
map_title <- "<h3 style='text-align:center; background-color:rgba(255,255,255,0.7); padding:2px;'>Ecoregions outside of the G Buffer areas</h3>"
map <- leaflet::addControl(leaflet::addLegend(leaflet::addPolygons(leaflet::addTiles(leaflet()),
data = ecoSelect, color = "#444444", weight = 1, opacity = 1,
fillOpacity = 0.1, popup = ~ECO_NAME, fillColor = NA),
position = "topright", title = "ERS ex situ", colors = c("#47ae24",
"#746fae", "#f0a01f", "#44444440"), labels = c("Distribution",
"G buffer", "Eco gaps", "All Ecos"), opacity = 1),
html = map_title, position = "bottomleft")
if (ers > 0) {
map <- leaflet::addCircleMarkers(leaflet::addRasterImage(leaflet::addRasterImage(leaflet::addPolygons(map,
data = missingEcos, color = "#444444", weight = 1,
opacity = 1, popup = ~ECO_NAME, fillOpacity = 0.5,
fillColor = "#f0a01f"), x = sdm, colors = "#47ae24"),
x = b1, colors = "#746fae"), data = d1, color = ~color,
radius = 2, opacity = 1)
}
else {
map <- leaflet::addCircleMarkers(map, data = d1, color = ~color,
radius = 2, opacity = 1)
}
output <- list(results = out_df, ecoGaps = missingEcos, map = map)
return(output)
}
n <- 1
for (i in species) {
export <- paste0("data/Vitis/varBuffer/", i, "_", buffSize, ".csv")
if (!file.exists(export)) {
print(i)
rs <- r2[grepl(pattern = paste0(i, "/"), x = r2)]
if (length(rs) == 0) {
next
}
sdm <- rast(rs)
sdm[sdm == 0, ] <- NA
p1 <- sf::st_read(s2[grepl(pattern = paste0(i,"/"), x = s2) ])
occurrenceData <- p1 |>
as.data.frame() |>
dplyr::select(
species= taxon,  latitude, longitude, type
)
# p1 <- vect(s2[grepl(pattern = paste0(i, "/"), x = s2)])
# limit ecoregions to the areas with known occurrences
# eco1 <- ecoregions[p1, ]
# occurrenceData is used for srsex
srs_exsitu <- GapAnalysis::SRSex(
taxon = i,
occurrence_Data = occurrenceData1
)
# need to use the spatial data as this is watch was evaluated within the model
spatialData <- as.data.frame(p1) |>
dplyr::select(
species = taxon,
latitude,
longitude,
type
)
# testing
## Generate buffer objects
gBuffer <- generateGBuffers(
taxon = i,
occurrenceData = occurrenceData,
bufferDistM = buffSize
)
## geographic representativeness score  exsitu
grs_exsitu <- GRSex(taxon = i,
sdm = sdm,
gBuffer = gBuffer)
## map is not clipping the buffer objects to the distribution
## Ecological representativeness score exsitu
ers_exsitu <- ERSex(
taxon = i,
sdm = sdm,
occurrenceData = occurrenceData,
gBuffer = gBuffer,
ecoregions = ecoregions,
idColumn = "ECO_CODE"
)
# Running final conservation score ecoregionsexsitu
fcs_exsitu <- FCSex(
taxon = i,
srsex = srs_exsitu,
grsex = grs_exsitu,
ersex = ers_exsitu
)
# generate insitu conservation summaries
## sample representativeness score insitu
srs_insitu <- SRSin(
taxon = i,
sdm = sdm,
occurrenceData = spatialData,
protectedAreas = protectedAreas
)
## Geographic representativeness score insitu
grs_insitu <- GRSin(taxon = i, sdm = sdm, protectedAreas = protectedAreas)
## ecological representativeness score insitu
ers_insitu <- ERSin(
taxon = i,
sdm = sdm,
occurrenceData = occurrenceData,
protectedAreas = protectedAreas,
ecoregions = ecoregions,
idColumn = "ECO_CODE"
)
## final representativeness score insitu
fcs_insitu <- FCSin(
taxon = i,
srsin = srs_insitu,
grsin = grs_insitu,
ersin = ers_insitu
)
## combine conservation score
fcs_combine <- FCSc_mean(taxon = i, fcsin = fcs_insitu, fcsex = fcs_exsitu)
write_csv(x = fcs_combine, file = export)
} else {
fcs_combine <- read_csv(export)
}
if (n == 1) {
output <- fcs_combine
} else {
output <- bind_rows(output, fcs_combine)
}
n = n + 1
}
buffSize
output
write_csv(x = output, file = paste0("data/Vitis/varBuffer/summaryTable_",buffSize,".csv" ))
# join the data and export
s1 <- list.files("data/Vitis/varBuffer/",
pattern = "summaryTable",
full.names = TRUE) |>
read_csv()
s1
write_csv(s1, "data/Vitis/varBuffer/full_set.csv")
# join the data and export
s1 <- list.files("data/Vitis/varBuffer/",
pattern = "summaryTable",
full.names = TRUE)
s1
# join the data and export
s1 <- list.files("data/Vitis/varBuffer/",
pattern = "summaryTable",
full.names = TRUE) |>
read_csv()
rep("10000", 35)
# join the data and export
s1 <- list.files("data/Vitis/varBuffer/",
pattern = "summaryTable",
full.names = TRUE) |>
read_csv() |>
dplyr::mutate(
bufferSize = c(
rep("10k", 35),
rep("100k", 35),
rep("50k", 35),
)
)
# join the data and export
s1 <- list.files("data/Vitis/varBuffer/",
pattern = "summaryTable",
full.names = TRUE) |>
read_csv() |>
dplyr::mutate(
bufferSize = c(
rep("10k", 35),
rep("100k", 35),
rep("50k", 35)
)
)
write_csv(s1, "data/Vitis/varBuffer/full_set.csv")
s1 <- read_csv("data/Vitis/varBuffer/full_set.csv")
s1 <- readr::read_csv("data/Vitis/varBuffer/full_set.csv")
View(s1)
